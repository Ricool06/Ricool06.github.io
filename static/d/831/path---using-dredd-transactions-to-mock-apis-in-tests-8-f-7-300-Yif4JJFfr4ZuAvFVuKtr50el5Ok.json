{"data":{"markdownRemark":{"html":"<p>Just a quick one today. I've been working on my final year project at university, and I've decided to use <a href=\"https://dredd.org/en/latest/\">dredd</a> for contract testing my services. One stumbling block I came across was testing the frontend against these contracts. I discovered a way to get around this problem by generating mock responses using <a href=\"https://github.com/apiaryio/dredd-transactions\">dredd-transactions</a> which is the library dredd itself uses to create transaction objects under the hood.</p>\n<p>Let's get on with it shall we?</p>\n<h3>The Setup</h3>\n<p>My project's frontend is an Angular 7 application, using protractor for its E2E tests, as is standard. The frontend calls <a href=\"https://openaq.org\">OpenAQ's</a> API and displays air quality measurements on a map. <a href=\"https://github.com/Ricool06/breathe\">Check out the code if you're interested</a>.</p>\n<h3>The Contract</h3>\n<p>In a folder called <code>blueprints</code>, I have documented the parts of OpenAQ's API that I am using. I've used <a href=\"https://apiblueprint.org/\">API Blueprint</a> for this documentation, then I convert it to <a href=\"https://swagger.io/\">Swagger/OpenAPI JSON</a> during the tests using <a href=\"https://github.com/kminami/apib2swagger\">apib2swagger</a>, but feel free to use Swagger or API blueprint directly if you prefer, as dredd supports both. I find that my approach gives me the best of both worlds, however, with the readability of API Blueprint, and the ability to use the Swagger JSON file in unit tests rather than bloating them with hundreds of object literals.</p>\n<h3>The Code</h3>\n<p>Before any of the tests run, in my <code>beforeAll</code> section, I read the content of the blueprint file into a variable, to prevent excessive disk IO before every test. I also set up a CORS-enabled express instance, which listens for any request sent to it, and forwards it onto a utility method, <code>matchRequestWithResponse</code>.</p>\n<pre><code>let transactionsMap;\nlet openaqBlueprint;\nlet openaqBlueprintFilePath;\nlet mockOpenaqApiServer;\n\nbeforeAll(() => {\n  transactionsMap = new Map&#x3C;string, any>();\n\n  openaqBlueprintFilePath = `${__dirname}/../../blueprints/openaq.apib.md`;\n  openaqBlueprint = readFileSync(openaqBlueprintFilePath, 'utf8');\n\n  const mockOpenaqApi = express();\n  mockOpenaqApi.use(cors());\n\n  mockOpenaqApi.all('*', matchRequestWithResponse);\n\n  mockOpenaqApiServer = mockOpenaqApi.listen(environment.openaqApi.port);\n});\n</code></pre>\n<p>Then, before each test, the blueprint is compiled into a set of dredd transactions (basically request/response pairs) and added to a map with the HTTP method and URI forming the key.</p>\n<pre><code>beforeEach(() => {\n  dt.compile(openaqBlueprint, openaqBlueprintFilePath, (error, result) => {\n    expect(error).toBeFalsy();\n    result.transactions\n      .map(transaction => transactionsMap.set(\n        generateTransactionMapKey(transaction.request.method, transaction.request.uri),\n        transaction));\n  });\n\n  page = new MapPage();\n});\n\nfunction generateTransactionMapKey(method, uri) {\n  return `${method} ${url.parse(uri).pathname}`;\n}\n</code></pre>\n<p>When a request is made by the app to the mock server, that request is matched up with the transaction in the map, then the response counterpart is returned by the express server. This is done by the <code>matchRequestWithResponse</code> function mentioned earlier.</p>\n<pre><code>function matchRequestWithResponse(req: express.Request, res: express.Response) {\n  const { response } = transactionsMap.get(generateTransactionMapKey(req.method, req.url));\n\n  res.status(response.status).json(JSON.parse(response.body));\n}\n\nfunction generateTransactionMapKey(method, uri) {\n  return `${method} ${url.parse(uri).pathname}`;\n}\n</code></pre>\n<h3>Bonus: Unit Tests</h3>\n<p>The Swagger JSON can also be imported into unit tests for sample data too, with a couple of caveats:</p>\n<ul>\n<li>The TypeScript compiler option <code>resolveJsonModule</code> must be set to true in <code>tsconfig.json</code>. </li>\n<li>When you import the Swagger file <strong>the object is cached</strong>, meaning you should probably clone the object if you plan on changing some of the values if you don't want to break subsequent tests that rely on the original data. (<a href=\"https://lodash.com/\">Lodash</a> has a nice <code>cloneDeep</code> function I like to use.)</li>\n</ul>\n<h3>Conclusion</h3>\n<p>I've found this method works quite well so far, and I can be sure that if OpenAQ's API ever changes, I can simply change the blueprint and fix any failing tests. More importantly, when I come to include my own backend services, I can facilitate the consumer-driven-contracts pattern for testing the frontend by automatically mocking my backend service. Any tests between multiple backend services can simply run dredd the traditional way, giving me confidence that all of the services in my system work together without <em>necessarily</em> needing a full suite of system tests.</p>\n<p>I'm still learning, so there might be a glaring issue with this approach that I'm not yet aware of. If so, feel free to contact me on <a href=\"https://twitter.com/Ricool06\">Twitter</a>!</p>","frontmatter":{"date":"March 18, 2019","path":"/using-dredd-transactions-to-mock-apis-in-tests","title":"Using Dredd transactions to mock APIs in tests"}}},"pageContext":{}}